// ../../node_modules/@lit/context/development/lib/context-request-event.js
var ContextRequestEvent = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(context, callback, subscribe) {
    super("context-request", { bubbles: true, composed: true });
    this.context = context;
    this.callback = callback;
    this.subscribe = subscribe ?? false;
  }
};

// ../../node_modules/@lit/context/development/lib/create-context.js
function createContext(key) {
  return key;
}

// ../../node_modules/@lit/context/development/lib/controllers/context-consumer.js
var ContextConsumer = class {
  constructor(host, contextOrOptions, callback, subscribe) {
    this.subscribe = false;
    this.provided = false;
    this.value = void 0;
    this._callback = (value, unsubscribe) => {
      if (this.unsubscribe) {
        if (this.unsubscribe !== unsubscribe) {
          this.provided = false;
          this.unsubscribe();
        }
        if (!this.subscribe) {
          this.unsubscribe();
        }
      }
      this.value = value;
      this.host.requestUpdate();
      if (!this.provided || this.subscribe) {
        this.provided = true;
        if (this.callback) {
          this.callback(value, unsubscribe);
        }
      }
      this.unsubscribe = unsubscribe;
    };
    this.host = host;
    if (contextOrOptions.context !== void 0) {
      const options = contextOrOptions;
      this.context = options.context;
      this.callback = options.callback;
      this.subscribe = options.subscribe ?? false;
    } else {
      this.context = contextOrOptions;
      this.callback = callback;
      this.subscribe = subscribe ?? false;
    }
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = void 0;
    }
  }
  dispatchRequest() {
    this.host.dispatchEvent(new ContextRequestEvent(this.context, this._callback, this.subscribe));
  }
};

// ../../node_modules/@lit/context/development/lib/value-notifier.js
var ValueNotifier = class {
  get value() {
    return this._value;
  }
  set value(v) {
    this.setValue(v);
  }
  setValue(v, force = false) {
    const update = force || !Object.is(v, this._value);
    this._value = v;
    if (update) {
      this.updateObservers();
    }
  }
  constructor(defaultValue) {
    this.subscriptions = /* @__PURE__ */ new Map();
    this.updateObservers = () => {
      for (const [callback, { disposer }] of this.subscriptions) {
        callback(this._value, disposer);
      }
    };
    if (defaultValue !== void 0) {
      this.value = defaultValue;
    }
  }
  addCallback(callback, consumerHost, subscribe) {
    if (!subscribe) {
      callback(this.value);
      return;
    }
    if (!this.subscriptions.has(callback)) {
      this.subscriptions.set(callback, {
        disposer: () => {
          this.subscriptions.delete(callback);
        },
        consumerHost
      });
    }
    const { disposer } = this.subscriptions.get(callback);
    callback(this.value, disposer);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};

// ../../node_modules/@lit/context/development/lib/controllers/context-provider.js
var ContextProviderEvent = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   */
  constructor(context) {
    super("context-provider", { bubbles: true, composed: true });
    this.context = context;
  }
};
var ContextProvider = class extends ValueNotifier {
  constructor(host, contextOrOptions, initialValue) {
    var _a, _b;
    super(contextOrOptions.context !== void 0 ? contextOrOptions.initialValue : initialValue);
    this.onContextRequest = (ev) => {
      const consumerHost = ev.composedPath()[0];
      if (ev.context !== this.context || consumerHost === this.host) {
        return;
      }
      ev.stopPropagation();
      this.addCallback(ev.callback, consumerHost, ev.subscribe);
    };
    this.onProviderRequest = (ev) => {
      const childProviderHost = ev.composedPath()[0];
      if (ev.context !== this.context || childProviderHost === this.host) {
        return;
      }
      const seen = /* @__PURE__ */ new Set();
      for (const [callback, { consumerHost }] of this.subscriptions) {
        if (seen.has(callback)) {
          continue;
        }
        seen.add(callback);
        consumerHost.dispatchEvent(new ContextRequestEvent(this.context, callback, true));
      }
      ev.stopPropagation();
    };
    this.host = host;
    if (contextOrOptions.context !== void 0) {
      this.context = contextOrOptions.context;
    } else {
      this.context = contextOrOptions;
    }
    this.attachListeners();
    (_b = (_a = this.host).addController) == null ? void 0 : _b.call(_a, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest);
    this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new ContextProviderEvent(this.context));
  }
};

// ../../node_modules/@lit/context/development/lib/context-root.js
var ContextRoot = class {
  constructor() {
    this.pendingContextRequests = /* @__PURE__ */ new Map();
    this.onContextProvider = (event) => {
      const pendingRequestData = this.pendingContextRequests.get(event.context);
      if (pendingRequestData === void 0) {
        return;
      }
      this.pendingContextRequests.delete(event.context);
      const { requests } = pendingRequestData;
      for (const { elementRef, callbackRef } of requests) {
        const element = elementRef.deref();
        const callback = callbackRef.deref();
        if (element === void 0 || callback === void 0) {
        } else {
          element.dispatchEvent(new ContextRequestEvent(event.context, callback, true));
        }
      }
    };
    this.onContextRequest = (event) => {
      if (event.subscribe !== true) {
        return;
      }
      const element = event.composedPath()[0];
      const callback = event.callback;
      let pendingContextRequests = this.pendingContextRequests.get(event.context);
      if (pendingContextRequests === void 0) {
        this.pendingContextRequests.set(event.context, pendingContextRequests = {
          callbacks: /* @__PURE__ */ new WeakMap(),
          requests: []
        });
      }
      let callbacks = pendingContextRequests.callbacks.get(element);
      if (callbacks === void 0) {
        pendingContextRequests.callbacks.set(element, callbacks = /* @__PURE__ */ new WeakSet());
      }
      if (callbacks.has(callback)) {
        return;
      }
      callbacks.add(callback);
      pendingContextRequests.requests.push({
        elementRef: new WeakRef(element),
        callbackRef: new WeakRef(callback)
      });
    };
  }
  /**
   * Attach the ContextRoot to a given element to intercept `context-request` and
   * `context-provider` events.
   *
   * @param element an element to add event listeners to
   */
  attach(element) {
    element.addEventListener("context-request", this.onContextRequest);
    element.addEventListener("context-provider", this.onContextProvider);
  }
  /**
   * Removes the ContextRoot event listeners from a given element.
   *
   * @param element an element from which to remove event listeners
   */
  detach(element) {
    element.removeEventListener("context-request", this.onContextRequest);
    element.removeEventListener("context-provider", this.onContextProvider);
  }
};

// ../../node_modules/@lit/context/development/lib/decorators/provide.js
function provide({ context }) {
  return (protoOrTarget, nameOrContext) => {
    const controllerMap = /* @__PURE__ */ new WeakMap();
    if (typeof nameOrContext === "object") {
      nameOrContext.addInitializer(function() {
        controllerMap.set(this, new ContextProvider(this, { context }));
      });
      return {
        get() {
          return protoOrTarget.get.call(this);
        },
        set(value) {
          var _a;
          (_a = controllerMap.get(this)) == null ? void 0 : _a.setValue(value);
          return protoOrTarget.set.call(this, value);
        },
        init(value) {
          var _a;
          (_a = controllerMap.get(this)) == null ? void 0 : _a.setValue(value);
          return value;
        }
      };
    } else {
      protoOrTarget.constructor.addInitializer((element) => {
        controllerMap.set(element, new ContextProvider(element, { context }));
      });
      const descriptor = Object.getOwnPropertyDescriptor(protoOrTarget, nameOrContext);
      let newDescriptor;
      if (descriptor === void 0) {
        const valueMap = /* @__PURE__ */ new WeakMap();
        newDescriptor = {
          get: function() {
            return valueMap.get(this);
          },
          set: function(value) {
            controllerMap.get(this).setValue(value);
            valueMap.set(this, value);
          },
          configurable: true,
          enumerable: true
        };
      } else {
        const oldSetter = descriptor.set;
        newDescriptor = {
          ...descriptor,
          set: function(value) {
            controllerMap.get(this).setValue(value);
            oldSetter == null ? void 0 : oldSetter.call(this, value);
          }
        };
      }
      Object.defineProperty(protoOrTarget, nameOrContext, newDescriptor);
      return;
    }
  };
}

// ../../node_modules/@lit/context/development/lib/decorators/consume.js
function consume({ context, subscribe }) {
  return (protoOrTarget, nameOrContext) => {
    if (typeof nameOrContext === "object") {
      nameOrContext.addInitializer(function() {
        new ContextConsumer(this, {
          context,
          callback: (value) => {
            this[nameOrContext.name] = value;
          },
          subscribe
        });
      });
    } else {
      protoOrTarget.constructor.addInitializer((element) => {
        new ContextConsumer(element, {
          context,
          callback: (value) => {
            element[nameOrContext] = value;
          },
          subscribe
        });
      });
    }
  };
}
export {
  ContextConsumer,
  ContextRequestEvent as ContextEvent,
  ContextProvider,
  ContextRoot,
  consume,
  createContext,
  provide
};
/*! Bundled license information:

@lit/context/development/lib/context-request-event.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/create-context.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/controllers/context-consumer.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/value-notifier.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/controllers/context-provider.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/context-root.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/decorators/provide.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/decorators/consume.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/index.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@lit_context.js.map
